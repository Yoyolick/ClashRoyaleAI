# A python program that attempts to play clash royale
# Ryan Zmuda 2021

import pyautogui
import win32gui
from PIL import Image, ImageEnhance, ImageFilter, ImageOps
import keyboard
import pytesseract as tess
from datetime import datetime
import re
import time
import json

# defualts
elixerStoreValue = 0

firstCardCost = 0
secondCardCost = 0
thirdCardCost = 0
fourthCardCost = 0

# raidus of pixels to encompass text in recognition
elixerStoreScanRadius = 25
cardScanRadius = 15

# load our game coordinates from screenPoints.json (generated by configure.py)
# TODO THESE ALL MIGHT NEED ADJUSTED TO LOCALLY FOR CROP
with open("screenPoints.json") as json_file:
    # throw the json data into an object
    data = json.load(json_file)

    # screen origin coords
    screenOrigin = tuple(data["screenOrigin"])
    screenBotRight = tuple(data["screenBotRight"])

    # elixer store text position adjusted for screen origin converted to a tuple
    elixerStoreTextPos = (
        data["elixerTextCoords"][0] - screenOrigin[0],
        data["elixerTextCoords"][1] - screenOrigin[1],
    )

    # card price text position
    card1textCoords = (
        data["card1textCoords"][0] - screenOrigin[0],
        data["card1textCoords"][1] - screenOrigin[1],
    )
    card2textCoords = (
        data["card2textCoords"][0] - screenOrigin[0],
        data["card2textCoords"][1] - screenOrigin[1],
    )
    card3textCoords = (
        data["card3textCoords"][0] - screenOrigin[0],
        data["card3textCoords"][1] - screenOrigin[1],
    )
    card4textCoords = (
        data["card4textCoords"][0] - screenOrigin[0],
        data["card4textCoords"][1] - screenOrigin[1],
    )

    # place points for units
    aboveLeftTower = tuple(data["aboveLeftTower"])
    aboveRightTower = tuple(data["aboveRightTower"])
    leftPushed = tuple(data["leftPushed"])
    rightPushed = tuple(data["rightPushed"])

    # coords to click on cards to select them
    firstCardCoords = tuple(data["card1position"])
    secondCardCoords = tuple(data["card2position"])
    thirdCardCoords = tuple(data["card3position"])
    fourthCardCoords = tuple(data["card4position"])

# figure out our width and height of screen
screenSize = (screenBotRight[0] - screenOrigin[0], screenBotRight[1] - screenOrigin[1])

# tell program we dont know any of our deck cards TODO this shit needs to be done better or removed
usedFC = True
usedSC = True
usedTC = True
usedFTHC = True

# set tesseract path
with open("tesseractPath.txt", "r") as tessPath:
    tess.pytesseract.tesseract_cmd = tessPath.read()


def screenshot(window_title=None):
    if window_title:
        hwnd = win32gui.FindWindow(None, window_title)
        if hwnd:
            win32gui.SetForegroundWindow(hwnd)
            x, y, x1, y1 = win32gui.GetClientRect(hwnd)
            x, y = win32gui.ClientToScreen(hwnd, (x, y))
            x1, y1 = win32gui.ClientToScreen(hwnd, (x1 - x, y1 - y))
            im = pyautogui.screenshot(region=(x, y, x1, y1))
            return im
        else:
            print("Window not found!")
    else:
        im = pyautogui.screenshot()
        return im


# get size of our current bluestacks window
im = screenshot("BlueStacks")
bluestacksSize = im.size

# calculate our crop amounts from our given playfield size and window size
cropTL = (0, bluestacksSize[1] - screenSize[1])
cropBR = (screenSize[0], bluestacksSize[1])


def filterImage(img):
    # condensed filtering to grayscale binary image for easier recognition
    img = (
        img.convert("L")
        .filter(ImageFilter.MedianFilter())
        .point(lambda x: 0 if x < 220 else 255)
    )
    return img


# TODO might need to put num filter back idk 4 is fucky  -c tessedit_char_whitelist=1234567890


def tessParse(im):
    # parse our text and
    detectedText = tess.image_to_string(im, config="--psm 13")
    # 4 is commonly mistaken for Q in the clash royale font, correct for this
    if "q" in detectedText:
        detectedText = "4"
    # clean detected text for any letters wrongly recognised TODO remove this if i enable the character whitelsit
    # print("detected text:", detectedText)
    detectedText = re.sub(
        "[^0-9]", "", detectedText
    )  # this is regex! wow im so god damn smart >:) totally didnt copy it from somewhere

    # return detected text corrected for recognition errors
    return detectedText


# TODO REMOVE left, top, right, bottom


def parseStaticValues(
    elixerStoreValue,
    usedFirstCardSinceLastCheck,
    usedSecondCardSinceLastCheck,
    usedThirdCardSinceLastCheck,
    usedFourthCardSinceLastCheck,
    firstCardCost,
    secondCardCost,
    thirdCardCost,
    fourthCardCost,
):

    parseValuesElapsedTime = datetime.now()

    # TODO TEST FILTERING ONE TIME FOR EFFICIENCY

    # with Image.open("images/playfield.png") as im:  # TODO THIS NEEDS TO GO
    # use currently grabbed im for evaluation

    # TODO hard code this dont run computations every frame
    elixerStoreImg = im.crop(
        (
            (elixerStoreTextPos[0] - elixerStoreScanRadius),
            (elixerStoreTextPos[1] - elixerStoreScanRadius),
            (elixerStoreTextPos[0] + elixerStoreScanRadius),
            (elixerStoreTextPos[1] + elixerStoreScanRadius),
        )
    )
    # elixerStoreImg.show()
    # update current elixer store value based off playfield image
    elixerStoreImg = filterImage(elixerStoreImg)
    # elixerStoreImg.show()

    # defualt to last known value if we dont know our current
    tmp = tessParse(elixerStoreImg)
    if tmp != "":
        elixerStoreValue = tmp
    print("elixer store value:", elixerStoreValue)

    # only check for card values if we know we have a different card

    if usedFirstCardSinceLastCheck:
        # update first card elixer value
        firstCardPriceImg = im.crop(
            (
                (card1textCoords[0] - cardScanRadius),
                (card1textCoords[1] - cardScanRadius),
                (card1textCoords[0] + cardScanRadius),
                (card1textCoords[1] + cardScanRadius),
            )
        )
        firstCardPriceImg = filterImage(firstCardPriceImg)
        firstCardPriceImg.show()
        # firstCardPriceImg.show()
        tmp = tessParse(firstCardPriceImg)
        if tmp != "":
            firstCardCost = tmp
        print("first card price:", firstCardCost)
        # usedFirstCardSinceLastCheck = False

    if usedSecondCardSinceLastCheck:
        # update second card elixer value
        secondCardPriceImg = im.crop(
            (
                (card2textCoords[0] - cardScanRadius),
                (card2textCoords[1] - cardScanRadius),
                (card2textCoords[0] + cardScanRadius),
                (card2textCoords[1] + cardScanRadius),
            )
        )
        secondCardPriceImg = filterImage(secondCardPriceImg)
        secondCardPriceImg.show()
        # secondCardPriceImg.show()
        tmp = tessParse(secondCardPriceImg)
        if tmp != "":
            secondCardCost = tmp
        print("second card price:", secondCardCost)
        # usedSecondCardSinceLastCheck = False

    if usedThirdCardSinceLastCheck:
        # update third card elixer value
        thirdCardPriceImg = im.crop(
            (
                (card3textCoords[0] - cardScanRadius),
                (card3textCoords[1] - cardScanRadius),
                (card3textCoords[0] + cardScanRadius),
                (card3textCoords[1] + cardScanRadius),
            )
        )
        thirdCardPriceImg = filterImage(thirdCardPriceImg)
        thirdCardPriceImg.show()
        # thirdCardPriceImg.show()
        tmp = tessParse(thirdCardPriceImg)
        if tmp != "":
            thirdCardCost = tmp
        print("third card price:", thirdCardCost)
        # usedThirdCardSinceLastCheck = False

    if usedFourthCardSinceLastCheck:
        # update fourth card elixer value
        fourthCardPriceImg = im.crop(
            (
                (card4textCoords[0] - cardScanRadius),
                (card4textCoords[1] - cardScanRadius),
                (card4textCoords[0] + cardScanRadius),
                (card4textCoords[1] + cardScanRadius),
            )
        )
        fourthCardPriceImg = filterImage(fourthCardPriceImg)
        fourthCardPriceImg.show()
        exit()
        # fourthCardPriceImg.show()
        tmp = tessParse(fourthCardPriceImg)
        if tmp != "":
            fourthCardCost = tmp
        print("fourth card price:", fourthCardCost)
        # usedFourthCardSinceLastCheck = False

    print("elapsed static parse time:", datetime.now() - parseValuesElapsedTime)


# card location possibilities:
# - leftAboveTower
# - rightAboveTower
# - leftPushedTower
# - rightPushedTower
# - defendLeftCastle
# - defendRightCastle
# -

# starting this index from 1 because its possibly faster (yes i know, barely if at all)
def placeCard(location, cardIndex):

    # click on the card we want to use
    if cardIndex == 1:
        pyautogui.click(firstCardCoords[0], firstCardCoords[1])
    elif cardIndex == 2:
        pyautogui.click(secondCardCoords[0], secondCardCoords[1])
    elif cardIndex == 3:
        pyautogui.click(thirdCardCoords[0], thirdCardCoords[1])
    elif cardIndex == 4:
        pyautogui.click(fourthCardCoords[0], fourthCardCoords[1])

    # place the card in our desired location
    if location == "leftAboveTower":
        pyautogui.click(aboveLeftTower[0], aboveLeftTower[1])
    elif location == "rightAboveTower":
        pyautogui.click(aboveRightTower[0], aboveRightTower[1])
    elif location == "leftPushedTower":
        # TODO
        return
    elif location == "rightPushedTower":
        # TODO
        return
    elif location == "defendLeftCastle":
        # TODO
        return
    elif location == "defendRightCastle":
        # TODO
        return

    # let the program know we need to scan for new value in spot of whichever card we just used
    if cardIndex == 1:
        usedFC = True
    elif cardIndex == 2:
        usedSC = True
    elif cardIndex == 3:
        usedTC = True
    elif cardIndex == 4:
        usedFTHC = True


# BASIC STATEGIES

# pick the cheapest presented card at all times and place it
def placeCheapestCard():
    possibleCards = [
        int(firstCardCost),
        int(secondCardCost),
        int(thirdCardCost),
        int(fourthCardCost),
    ]
    # get index of smallest item in list
    cardNumber = (
        possibleCards.index(min(possibleCards)) + 1
    )  # add one because lists start at 0

    placeCard("leftAboveTower", cardNumber)


if __name__ == "__main__":
    while True:
        # get a screenshot of the playfield

        im = screenshot("BlueStacks")
        im = im.crop(
            (
                cropTL[0],
                cropTL[1],
                cropBR[0],
                cropBR[1],
            )  # crop by our playfield bounds in relation to the bluestacks window
        )  # TODO YO RYAN THIS IS WHAT YOU NEED TO DO RN!!!! LOOK AT NOTEBOOK NOTE
        # im.show()
        im.save("images/playfield.png")  # TODO remove the save for efficiency

        # parse playfield for elixer store and our four card prices
        parseStaticValues(
            elixerStoreValue,
            usedFC,
            usedSC,
            usedTC,
            usedFTHC,
            firstCardCost,
            secondCardCost,
            thirdCardCost,
            fourthCardCost,
        )
        time.sleep(1)

        placeCheapestCard()

        # emergency abort
        if keyboard.is_pressed("q"):
            print("-> EMERGENCY EXIT")
            exit()


# pyautogui.click(gameOrigin[0], gameOrigin[1])
# keyboard.press("1")

# mental map:
# - find single digit numbers for rank of enemy units
# - maybe put filters on image one time and crop from that to make easier? wait maybe not due to differing thresholds
# - TODO next step: isolate red pixels on screen to detect enemies
# TODO GETS INNACURATE CARD PRICE AND KEEPS IT

# WHERE I LEFT OFF
# wrote a very basic attack pattern of spamming left lane
# WHAT YOU SHOULD DO:
# write more attack patterns for fun
# start detecting enemies and countering (detect via clusters or something maybe) red filter over playfield
# TODO width might be fucky for text prob dont hardcode this