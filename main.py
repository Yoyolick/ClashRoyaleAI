# A python program that attempts to play clash royale
# Ryan Zmuda 2021

import pyautogui
import win32gui
from PIL import Image, ImageEnhance, ImageFilter, ImageOps
import keyboard
import pytesseract as tess
from datetime import datetime
import re
import time
import json
import random
import numpy as np
import cv2

# defualts
elixerStoreValue = 0

firstCardCost = 0
secondCardCost = 0
thirdCardCost = 0
fourthCardCost = 0

# raidus of pixels to encompass text in recognition
elixerStoreScanRadius = 25
cardScanRadius = 15

# load our game coordinates from screenPoints.json (generated by configure.py)
with open("screenPoints.json") as json_file:
    # throw the json data into an object
    data = json.load(json_file)

    # screen origin coords
    screenOrigin = tuple(data["screenOrigin"])
    screenBotRight = tuple(data["screenBotRight"])

    # elixer store text position adjusted for screen origin converted to a tuple
    elixerStoreTextPos = (
        data["elixerTextCoords"][0] - screenOrigin[0],
        data["elixerTextCoords"][1] - screenOrigin[1],
    )

    # card price text position
    card1textCoords = (
        data["card1textCoords"][0] - screenOrigin[0],
        data["card1textCoords"][1] - screenOrigin[1],
    )
    card2textCoords = (
        data["card2textCoords"][0] - screenOrigin[0],
        data["card2textCoords"][1] - screenOrigin[1],
    )
    card3textCoords = (
        data["card3textCoords"][0] - screenOrigin[0],
        data["card3textCoords"][1] - screenOrigin[1],
    )
    card4textCoords = (
        data["card4textCoords"][0] - screenOrigin[0],
        data["card4textCoords"][1] - screenOrigin[1],
    )

    # place points for units
    aboveLeftTower = tuple(data["aboveLeftTower"])
    aboveRightTower = tuple(data["aboveRightTower"])
    leftPushed = tuple(data["leftPushed"])
    rightPushed = tuple(data["rightPushed"])

    # coords to click on cards to select them
    firstCardCoords = tuple(data["card1position"])
    secondCardCoords = tuple(data["card2position"])
    thirdCardCoords = tuple(data["card3position"])
    fourthCardCoords = tuple(data["card4position"])

# figure out our width and height of screen
screenSize = (screenBotRight[0] - screenOrigin[0], screenBotRight[1] - screenOrigin[1])

# set tesseract path
with open("tesseractPath.txt", "r") as tessPath:
    tess.pytesseract.tesseract_cmd = tessPath.read()


def screenshot(window_title=None):
    if window_title:
        hwnd = win32gui.FindWindow(None, window_title)
        if hwnd:
            win32gui.SetForegroundWindow(hwnd)
            x, y, x1, y1 = win32gui.GetClientRect(hwnd)
            x, y = win32gui.ClientToScreen(hwnd, (x, y))
            x1, y1 = win32gui.ClientToScreen(hwnd, (x1 - x, y1 - y))
            im = pyautogui.screenshot(region=(x, y, x1, y1))
            return im
        else:
            print("Window not found!")
    else:
        im = pyautogui.screenshot()
        return im


# get size of our current bluestacks window
im = screenshot("BlueStacks")
bluestacksSize = im.size

# calculate our crop amounts from our given playfield size and window size
cropTL = (0, bluestacksSize[1] - screenSize[1])
cropBR = (screenSize[0], bluestacksSize[1])


def filterImage(img):
    # condensed filtering to grayscale binary image for easier recognition
    img = (
        img.convert("L")
        .filter(ImageFilter.MedianFilter())
        .point(lambda x: 0 if x < 220 else 255)
    )
    return img


def tessParse(im):
    # parse our text and
    detectedText = tess.image_to_string(im, config="--psm 13")
    # 4 is commonly mistaken for Q in the clash royale font, correct for this
    if "q" in detectedText:
        detectedText = "4"
    # print("detected text:", detectedText)
    detectedText = re.sub(
        "[^0-9]", "", detectedText
    )  # this is regex! wow im so god damn smart >:) totally didnt copy it from somewhere

    # return detected text corrected for recognition errors
    return detectedText


def parseStaticValues(
    elixerStoreValue,
    usedFirstCardSinceLastCheck,
    usedSecondCardSinceLastCheck,
    usedThirdCardSinceLastCheck,
    usedFourthCardSinceLastCheck,
    firstCardCost,
    secondCardCost,
    thirdCardCost,
    fourthCardCost,
):

    parseValuesElapsedTime = datetime.now()

    # TODO hard code this dont run computations every frame
    elixerStoreImg = im.crop(
        (
            (elixerStoreTextPos[0] - elixerStoreScanRadius),
            (elixerStoreTextPos[1] - elixerStoreScanRadius),
            (elixerStoreTextPos[0] + elixerStoreScanRadius),
            (elixerStoreTextPos[1] + elixerStoreScanRadius),
        )
    )
    # update current elixer store value based off playfield image
    elixerStoreImg = filterImage(elixerStoreImg)

    # defualt to last known value if we dont know our current
    tmp = tessParse(elixerStoreImg)
    if tmp != "":
        elixerStoreValue = tmp
    print("elixer store value:", elixerStoreValue)

    if usedFirstCardSinceLastCheck:
        # update first card elixer value# TODO hard code this dont run computations every frame
        firstCardPriceImg = im.crop(
            (
                (card1textCoords[0] - cardScanRadius),
                (card1textCoords[1] - cardScanRadius),
                (card1textCoords[0] + cardScanRadius),
                (card1textCoords[1] + cardScanRadius),
            )
        )
        firstCardPriceImg = filterImage(firstCardPriceImg)

        # only update value if it isnt null
        tmp = tessParse(firstCardPriceImg)
        if tmp != "":
            firstCardCost = tmp
        print("first card price:", firstCardCost)

    if usedSecondCardSinceLastCheck:
        # update second card elixer value# TODO hard code this dont run computations every frame
        secondCardPriceImg = im.crop(
            (
                (card2textCoords[0] - cardScanRadius),
                (card2textCoords[1] - cardScanRadius),
                (card2textCoords[0] + cardScanRadius),
                (card2textCoords[1] + cardScanRadius),
            )
        )
        secondCardPriceImg = filterImage(secondCardPriceImg)

        # only update value if it isnt null
        tmp = tessParse(secondCardPriceImg)
        if tmp != "":
            secondCardCost = tmp
        # TODO add if verbose here or clear screen between do this for all of them
        print("second card price:", secondCardCost)

    if usedThirdCardSinceLastCheck:
        # update third card elixer value# TODO hard code this dont run computations every frame
        thirdCardPriceImg = im.crop(
            (
                (card3textCoords[0] - cardScanRadius),
                (card3textCoords[1] - cardScanRadius),
                (card3textCoords[0] + cardScanRadius),
                (card3textCoords[1] + cardScanRadius),
            )
        )
        thirdCardPriceImg = filterImage(thirdCardPriceImg)

        # only update value if it isnt null
        tmp = tessParse(thirdCardPriceImg)
        if tmp != "":
            thirdCardCost = tmp
        print("third card price:", thirdCardCost)

    if usedFourthCardSinceLastCheck:
        # update fourth card elixer value# TODO hard code this dont run computations every frame
        fourthCardPriceImg = im.crop(
            (
                (card4textCoords[0] - cardScanRadius),
                (card4textCoords[1] - cardScanRadius),
                (card4textCoords[0] + cardScanRadius),
                (card4textCoords[1] + cardScanRadius),
            )
        )
        fourthCardPriceImg = filterImage(fourthCardPriceImg)

        # only update value if it isnt null
        tmp = tessParse(fourthCardPriceImg)
        if tmp != "":
            fourthCardCost = tmp
        print("fourth card price:", fourthCardCost)

    print("elapsed static parse time:", datetime.now() - parseValuesElapsedTime)


def detectEnemies(playfieldImage, query):

    topBoundsPercent = 0.11  # TODO expose this in the json to configure
    botBoundsPercent = 0.2  # to transform these points back onto our normal playfield we just need to add these bounds back as an offset

    playfieldImage = playfieldImage.crop(
        (
            0,
            screenSize[1] * topBoundsPercent,
            screenSize[0],
            screenSize[1] - screenSize[1] * botBoundsPercent,
        )
    )

    playfieldImage.save(
        "images/enemyDetect.png"
    )  # TODO convert to workable for PIL instead of saving

    # Load image
    im = cv2.imread("images/enemyDetect.png")

    # Define some colours for readability - these are in OpenCV **BGR** order - reverse them for PIL
    red = [236, 52, 52]
    green = [0, 255, 0]
    blue = [255, 0, 0]
    white = [255, 255, 255]
    black = [0, 0, 0]

    # Make all red pixels white AND at same time everything else black
    im = np.where(np.all(im == white, axis=-1, keepdims=True), white, black)
    if query == "reference":
        cv2.imwrite("images/enemyDetectRef.png", im)
        return im
    else:
        cv2.imwrite(
            "images/enemyDetect.png", cv2.absdiff(refIm, im)
        )  # diff between two images


# starting this index from 1 because its possibly faster (yes i know, barely if at all)
def placeCard(location, cardIndex):

    # click on the card we want to use
    if cardIndex == 1:
        pyautogui.click(firstCardCoords[0], firstCardCoords[1])
    elif cardIndex == 2:
        pyautogui.click(secondCardCoords[0], secondCardCoords[1])
    elif cardIndex == 3:
        pyautogui.click(thirdCardCoords[0], thirdCardCoords[1])
    elif cardIndex == 4:
        pyautogui.click(fourthCardCoords[0], fourthCardCoords[1])

    # place the card in our desired location
    if location == "leftAboveTower":
        pyautogui.click(aboveLeftTower[0], aboveLeftTower[1])
    elif location == "rightAboveTower":
        pyautogui.click(aboveRightTower[0], aboveRightTower[1])
    elif location == "leftPushedTower":
        # TODO
        return
    elif location == "rightPushedTower":
        # TODO
        return
    elif location == "defendLeftCastle":
        # TODO
        return
    elif location == "defendRightCastle":
        # TODO
        return

    # let the program know we need to scan for new value in spot of whichever card we just used
    if cardIndex == 1:
        usedFC = True
    elif cardIndex == 2:
        usedSC = True
    elif cardIndex == 3:
        usedTC = True
    elif cardIndex == 4:
        usedFTHC = True


# BASIC STATEGIES

# pick the cheapest presented card at all times and place it
def placeCheapestCard():
    possibleCards = [
        int(firstCardCost),
        int(secondCardCost),
        int(thirdCardCost),
        int(fourthCardCost),
    ]
    # get index of smallest item in list
    if min(possibleCards) != 0:
        cardNumber = (
            possibleCards.index(min(possibleCards)) + 1
        )  # add one because lists start at 0

        placeCard("leftAboveTower", cardNumber)
    else:
        cardNumber = random.randint(1, 4)
        placeCard("leftAboveTower", cardNumber)


if __name__ == "__main__":

    # TODO REMOVE FIRST BINDABLE FLOW TAKE SCREENSHOT ONE FRAME
    # idk what i mean by this comment but do this better have a first run function maybe
    im = screenshot("BlueStacks")
    # crop by our playfield bounds in relation to the bluestacks window
    im = im.crop(
        (
            cropTL[0],
            cropTL[1],
            cropBR[0],
            cropBR[1],
        )
    )
    refIm = detectEnemies(im, "reference")

    while True:
        # get a screenshot of the playfield

        im = screenshot("BlueStacks")
        # crop by our playfield bounds in relation to the bluestacks window
        im = im.crop(
            (
                cropTL[0],
                cropTL[1],
                cropBR[0],
                cropBR[1],
            )
        )
        # im.save("images/playfield.png")  # TODO REMOVE the save for efficiency (this is prob just for visualization)

        # parse playfield for elixer store and our four card prices
        parseStaticValues(
            elixerStoreValue,
            usedFC,
            usedSC,
            usedTC,
            usedFTHC,
            firstCardCost,
            secondCardCost,
            thirdCardCost,
            fourthCardCost,
        )

        detectEnemies(im, "i might be retarded possibly")

        # time.sleep(1)

        # emergency abort
        if keyboard.is_pressed("q"):
            print("-> EMERGENCY EXIT")
            exit()

# WHAT YOU SHOULD DO:
# write more attack patterns for fun
# start countering enemies (detect via clusters or something maybe)
# TODO AI check for red when holding card to know if tower is taken,
# TODO make it spam emotes would be a funny moment in the video
# https://stackoverflow.com/questions/60018903/how-to-replace-all-pixels-of-a-certain-rgb-value-with-another-rgb-value-in-openc todo look at this instead of PIL for cleaning elixer text
# TODO visualization mode for when you want to show off the AI working and another mode to toggle off the visuals for preformance (basically enables/disables image saving)